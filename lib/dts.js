"use strict";
var JayData = (function () {
    function JayData() {
    }
    JayData.src = "\ndeclare module $data{\n    class Geography{}\n    class GeographyLineString{}\n    class GeographyPolygon{}\n    class GeographyMultiPoint{}\n    class GeographyMultiPolygon{}\n    class GeographyMultiLineString{}\n    class GeographyCollection{}\n\n    class Geometry{}\n    class GeometryLineString{}\n    class GeometryPolygon{}\n    class GeometryMultiPoint{}\n    class GeometryMultiPolygon{}\n    class GeometryMultiLineString{}\n    class GeometryCollection{}\n\n    class Enum{}\n\tenum EntityState {\n        Detached = 0,\n        Unchanged = 10,\n        Added = 20,\n        Modified = 30,\n        Deleted = 40\n    }\n    class Entity{\n\t\tentityState: EntityState\n\t}\n    interface EntitySet<T extends Entity> extends Queryable<T>{\n        add(item: T): T;\n        add(initData: {}): T;\n        attach(item: T): void;\n        attach(item: {}): void;\n        attachOrGet(item: T): T;\n        attachOrGet(item: {}): T;\n        detach(item: T): void;\n        detach(item: {}): void;\n        remove(item: T): void;\n        remove(item: {}): void;\n        elementType: T;\n    }\n    class EntityContext{\n        constructor(config?: any);\n        onReady(): Promise<EntityContext>;\n        saveChanges(): Promise<number>;\n    }\n    \n    interface Promisable<T> {\n        forEach(handler: (it: T) => void): Promise<T>;\n        length(): Promise<number>;\n        toArray(): Promise<T[]>;\n        single(predicate: (it: T) => boolean, params?: any, handler?: (result: T) => void): Promise<T>;\n        first(predicate: (it: T) => boolean, params?: any, handler?: (result: T) => void ): Promise<T>;\n    }\n\n    interface Queryable<T> extends Promisable<T>{\n        filter(predicate: (it: T) => boolean, thisArg?: any): Queryable<T>;\n        map<TResult>(projection: (it: T) => any): Queryable<TResult>;\n        orderBy(predicate: (it: any) => any): Queryable<T>;\n        include(selector: string): Queryable<T>;\n        skip(amount: number): Queryable<T>;\n        take(amount: number): Queryable<T>;\n        removeAll(): Promise<number>;\n    }\n    interface Thenable<R> {\n        then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;\n        then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Thenable<U>;\n    }\n    interface Promise<R> extends Thenable<R> {\n        constructor(callback: (resolve : (value?: R | Thenable<R>) => void, reject: (error?: any) => void) => void);\n        then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Promise<U>;\n        then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Promise<U>;\n        catch<U>(onRejected?: (error: any) => U | Thenable<U>): Promise<U>;\n    }\n\n    class ServiceAction{}\n    class ServiceFunction{}\n}\n\ninterface String {\n    contains(s: string): boolean;\n    startsWith(s: string): boolean;\n    endsWith(s: string): boolean;\n    strLength(): number;\n    indexOf(s: string): number;\n    concat(s: string): string;\n}\n\ninterface Date {\n    day(): number;\n    hour(): number;\n    minute(): number;\n    month(): number;\n    second(): number;\n    year(): number;\n}\n\ninterface Number {\n    round(): number;\n    floor(): number;\n    ceiling(): number;\n}\n\ndeclare type jsDate = Date;\ndeclare module Edm {\n    type Boolean = boolean;\n    type Binary = Uint8Array;\n    type DateTime = jsDate;\n    type DateTimeOffset = jsDate;\n    type Duration = string;\n    type TimeOfDay = string;\n    type Date = string;\n    type Time = string;\n    type Decimal = string;\n    type Single = number;\n    type Float = number;\n    type Double = number;\n    type Guid = string;\n    type Int16 = number;\n    type Int32 = number;\n    type Int64 = string;\n    type Byte = number;\n    type SByte = number;\n    type String = string;\n    type GeographyPoint = $data.Geography;\n    type GeographyLineString = $data.GeographyLineString;\n    type GeographyPolygon = $data.GeographyPolygon;\n    type GeographyMultiPoint = $data.GeographyMultiPoint;\n    type GeographyMultiPolygon = $data.GeographyMultiPolygon;\n    type GeographyMultiLineString = $data.GeographyMultiLineString;\n    type GeographyCollection = $data.GeographyCollection;\n    type GeometryPoint = $data.Geometry;\n    type GeometryLineString = $data.GeometryLineString;\n    type GeometryPolygon = $data.GeometryPolygon;\n    type GeometryMultiPoint = $data.GeometryMultiPoint;\n    type GeometryMultiPolygon = $data.GeometryMultiPolygon;\n    type GeometryMultiLineString = $data.GeometryMultiLineString;\n    type GeometryCollection = $data.GeometryCollection;\n}\n";
    return JayData;
}());
exports.JayData = JayData;
//# sourceMappingURL=dts.js.map